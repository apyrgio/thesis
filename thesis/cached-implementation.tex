\chapter{Implementation of cached}\label{ch:cached-implementation}

In the previous chapter, we presented a design overview for cached and its 
components. In this chapter we will blabla how the above design has been
implemented and explain in depth the structures and functions that have been 
created for this purpose.

More specifically, sections ? - ? provide implementation information for the 
components of cached, as described in Chapter ?. Next, section ? presents the 
actual initialization and blabla operations using excerpts from the code.

\section{Implementation of xcache}

In this section, we describe how we implemented the design concept of section 
\ref{sec:xcache-design}. The main \xcache structure is the following:

\ccode{Main \xcache struct}{xcache-struct.h}

Each of the above xcache struct fields serves a design purpose.
Let's see which fields help in what:

\subsection{Entry Preallocation}

The relevant fields for this purpose can be seen in Listings 
\ref{xcache-prealloc.h}.

\ccode{xcache struct fields for preallocated entries}{xcache-prealloc.h}

When entries are preallocated, they take up a contiguous space in memory. The 
start of this space is the where the \texttt{*nodes} field points to. The type 
of this field is \texttt{xcache entry} so let's see the \texttt{xcache entry} 
struct:

\ccode{\texttt{xcache entry} struct}{xcache-entry.h}

The biggest field in the structure is the name field. Since we can't know 
beforehand the size of the object names, we must allocate enough space for the 
largest name possible. As of writing this, \texttt{XSEG\_MAX\_TARGETLEN} is 256 
characters. An interesting field is the \texttt{state} field, which is used to 
indicate whether the entry is evicted or not. The \text{volatile uint32\_t ref} 
field is used for reference counting reasons and will be discussed in depth in 
Paragraph \ref{par:refcount-imp}.

Finally, as we have mentioned in Section \ref{sec:entry-prealloc-design}, xcache 
must be agnostic of the cache contents.  To this end, we use the \texttt{void 
	*priv} field as a pointer to the real contents, which is a very common 
practice.

\subsection{Entry Indexing}

The relevant code for this purpose can be seen in Listings \ref{xcache-index.h}.

\ccode{xcache struct fields for entry indexing}{xcache-index.h}


\subsection{Concurrency control}

\paragraph{Reference counting}\label{par:refcount-imp}

The refcount model in xcache should be familiar to most people:

% Turn this to figure
\begin{itemize}
	\item When an entry is inserted in cache, the cache holds a reference 
		for it (ref = 1).
	\item Whenever a new lookup for this cache entry succeeds, the reference 
		is increased by 1 (ref++)
	\item When the request that has issued the lookup has finished with an 
		entry, the reference is decreased by 1. (ref--)
	\item When a cache entry is evicted by cache, the its ref is decreased 
		by 1. (ref--)
\end{itemize}

Some common refcount cases are:

\begin{itemize}
	\item active entry with pending jobs (ref > 1)
	\item active entry with no pending jobs (ref = 1)
	\item evicted entry with pending jobs (ref > 0)
	\item evicted entry with no pending jobs (ref = 0)
\end{itemize}

\begin{table}[tbp]
	\centering
	\begin{tabular}{ | l | l | }
		\hline
		Case & Refcount \\ \hline \hline
		active entry with pending jobs & ref > 1 \\ \hline
		active entry with no pending jobs & ref = 1 \\ \hline
		evicted entry with pending jobs & ref > 0 \\ \hline
		evicted entry with no pending jobs & ref = 0 \\ \hline
	\end{tabular}
	\caption{Reference counting of xcache}
	\label{tab:refcount}
\end{table}

and, as always, the entry is freed only when its ref = 0.

